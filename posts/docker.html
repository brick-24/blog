<html>
  <head>
    <meta charset="UTF-8" />
    <title>Docker for the Impatient, Explained Inadequately</title>
    <link rel="stylesheet" href="../css/style.css" />
  </head>
  <body>
    <main class="container">
      <h1 id="back">
        <a href="/index.html" style="text-decoration: none; color: #fff"
          ><- back</a
        >
      </h1>
      <h1>
        <span class="hash">#</span> Docker for the Impatient, Explained
        inadequately
      </h1>
      <p class="date">Posted on Dec 31, 2025</p>

      <p>
        Docker is used to run application in isolated environments called
        containers. This helps solve the 'it works on my machine' problem as
        docker puts apps into containers that are packaged with code,
        dependencies, system variables and tools. Each app has its own container
        so dependencies don't conflict between applications.
      </p>

      <h1 style="font-size: large">
        <span class="hash">##</span> The Docker File
      </h1>

      <p>
        Each project contains a docker file which includes the instructions on
        building the image for the app. Here is an example docker file which
        would be named: Dockerfile
      </p>

      <div class="code-block">
        <pre><code>FROM python:3.8
WORKDIR /app
RUN pip install -r requirements.txt
COPY . .
CMD ["python", "app.py"]</code></pre>
      </div>

      <p>- What this file means:</p>
      <div class="code-block">
        <pre><code>FROM python:3.8</code></pre>
      </div>

      <p>
        This gets the base image which contains a linux os and python 3.8
        installed, everything after this instruction builds on top of it
      </p>

      <div class="code-block">
        <pre><code>WORKDIR /app</code></pre>
      </div>

      <p>
        This is the working directory inside the image, if it dosen't exist
        docker will create it.
      </p>

      <div class="code-block">
        <pre><code>RUN pip install -r requirements.txt</code></pre>
      </div>
      <p>We use this to install all the dependencies required.</p>

      <div class="code-block">
        <pre><code>COPY . .</code></pre>
      </div>

      <p>
        This copies the application code into the image after the dependencies
        are installed.
      </p>

      <div class="code-block">
        <pre><code>CMD ["python", "app.py"]</code></pre>
      </div>
      <p>
        This defines the default command executed at runtime, for us it would be
        running the app.
      </p>

      <h1 style="font-size: large">
        <span class="hash">##</span> Docker Image
      </h1>

      <p>
        When we run the command <code>docker build -t app .</code> it tells the
        docker engine to build an image and assign the image a tag in the
        current directory. The image is stored locally on the machine in dockers
        image store which is managed by the docker engine.
      </p>

      <p>
        The image contains the filesystem, system libraries, installed
        dependencies and application source code. It does not include logs or
        dynamically generated data.
      </p>

      <h1 style="font-size: large">
        <span class="hash">##</span> Docker Container
      </h1>
      <p>
        Next, the <code>docker run tag</code> command is used to create and
        start containers from the image. This sets up the containers filesystem
        and executes the image's command CMD
      </p>

      <p>
        You can even map ports to containers, name them or override the default
        commands
        <li>
          <code> docker run -p 8000:8000 my-python-app </code>
        </li>
        <li><code>docker run --name my-container my-python-app </code></li>
        <li><code>docker run my-python-app python other.py </code></li>
      </p>

      <h1 style="font-size: large">
        <span class="hash">##</span> How I use docker for my portfolio site
      </h1>

      <p>
        I built my docker image locally for my portfolio then pushed the image
        to the artifact registry and configured Cloud Run to run the image and
        serve it when http requests hit my service
      </p>

      <p>
        Cloud run is able to scale one image to multiple container instances
        which are all isolated from one another and requests are load balanced
        automatically, instances can start and stop at any time
      </p>

      <p>
        Kubernetes automates deploying, scalinf and managing containers, however
        that is beyond the scope of this article.
      </p>

      <h1 style="font-size: large">
        <span class="hash">##</span> Further reading
      </h1>

      <a
        href="https://www.teodorwisniewski.com/from-dockerfile-to-deployment-navigating-dockers-build-ship-and-run-cycle-5"
        style="text-decoration: underline; color: gray"
        >From Dockerfile to Deployment: Navigating Docker's Build, Ship, and Run
        Cycle - Teodor Wisniewski May 21
      </a>

      <iframe
        width="600"
        height="400"
        src="https://www.youtube.com/embed/gAkwW2tuIqE"
        title="Learn Docker in 7 Easy Steps - Full Beginner&#39;s Tutorial"
        frameborder="0"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
        referrerpolicy="strict-origin-when-cross-origin"
        allowfullscreen
        style="display: block; margin: auto"
      ></iframe>

      <iframe
        width="600"
        height="400"
        src="https://www.youtube.com/embed/DQdB7wFEygo"
        title="The Only Docker Tutorial You Need To Get Started"
        frameborder="0"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
        referrerpolicy="strict-origin-when-cross-origin"
        allowfullscreen
        style="display: block; margin: auto"
      ></iframe>
    </main>
  </body>
</html>
